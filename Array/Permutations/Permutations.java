/*
Permutations 

Given a collection of numbers, return all possible permutations.

For example,
[1,2,3] have the following permutations:
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].
*/
import arrayUtil.*;
import java.util.*;

public class Permutations {
    public List<List<Integer>> permute(int[] num){
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        Integer[] numInt = new Integer[num.length];
        for(int i=0;i<num.length;i++) { numInt[i] = num[i]; }
        getPerm(numInt,0,numInt.length-1,result);
        return result;
    }

    private void getPerm(Integer[] num, int k, int end, List<List<Integer>> result){
        if(k == end)
            result.add(new ArrayList<Integer>(Arrays.asList(num)));
        else{
            for(int i=k;i<=end;i++){
                int temp = num[k];
                num[k] = num[i];
                num[i] = temp;
                getPerm(num,k+1,end,result);
                temp = num[k];
                num[k] = num[i];
                num[i] = temp;
            }
        }
    }
    
    public static void main(String args[]){
        int[] num = {1,2,3};
        List<List<Integer>> arr = (new Permutations()).permute(num);
        ArrayListUtil.printListList(arr);
    }
}

/*
The idea of this classic problem is to use backtracking.
We want to get permutations, which is mainly about swap values in the list.
Consider:
a --> a
ab --> ab, ba
abc --> abc, acb, bac, bca, cab, cba.
...
where for the length of n, the permutations can be generated by
(1) Swap the 1st element with all the elements, including itself.
(2) Then the 1st element is fixed, go to the next element.
(3) Until the last element is fixed. Output.

The key point is to make the big problem into smaller problem, 
here is how to convert the length n permutation into length n-1 
permutation problem.
*/